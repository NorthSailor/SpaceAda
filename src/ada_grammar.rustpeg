
use super::data_type;
use super::expression;
use super::statement;

pub statement -> statement::Statement
    = return_stmt / assignment_stmt / procedure_call_stmt

pub assignment_stmt -> statement::Statement
    = _ dest:identifier wh<":="> val:expression wh<";"> { statement::Statement::Assignment(dest, val) }

pub return_stmt -> statement::Statement
    = wh<"return"> val:expression? wh<";"> { statement::Statement::Return(val) }

pub procedure_call_stmt -> statement::Statement
    = _ name:identifier _ "(" params:parameter_list ")" wh<";"> { statement::Statement::ProcedureCall(name, params) } /
      _ name:identifier wh<";"> { statement::Statement::ProcedureCall(name, vec![]) }

pub expression -> expression::Expression
    = function_call_expr / binary_expr / terminal_expr

pub function_call_expr -> expression::Expression
    = name:identifier _ "(" params:parameter_list ")" { expression::Expression::FunctionCall(name, params) }

pub parameter_list -> Vec<expression::Expression>
    = expression ** wh<",">

pub binary_expr -> expression::Expression = #infix<terminal_expr> {
	#L x "+" y { expression::Expression::Binary("+".to_string(), Box::new(x), Box::new(y)) }
	   x "-" y { expression::Expression::Binary("-".to_string(), Box::new(x), Box::new(y)) }
	#L x "*" y { expression::Expression::Binary("*".to_string(), Box::new(x), Box::new(y)) }
	   x "/" y { expression::Expression::Binary("/".to_string(), Box::new(x), Box::new(y)) }
}

pub enclosed_expr -> expression::Expression
    = wh<"("> x:expression wh<")"> { x }

pub terminal_expr -> expression::Expression
    = enclosed_expr /
      _ x:int_value _ { expression::Expression::IntValue(x) } /
      _ x:identifier _ { expression::Expression::Variable(x) }

pub int_value -> i32
    = n:$("-"? [0-9]+) { n.parse().unwrap() }

pub identifier -> String
    = s:$([a-zA-Z][_a-zA-Z0-9]*) { s.to_string() }

pub data_type -> data_type::DataType
    = "Integer" { data_type::DataType::Integer }

wh<X> = _ X _

_ = ignored*
ignored = " " / "\n" 

