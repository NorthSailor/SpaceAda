
use super::data_type;
use super::expression;

pub expression -> expression::Expression
    = function_call_expr / binary_expr / terminal_expr

pub function_call_expr -> expression::Expression
    = name:identifier _ "(" params:parameter_list ")" { expression::Expression::FunctionCall(name, params) }

pub parameter_list -> Vec<expression::Expression>
    = expression ** wh<",">

pub binary_expr -> expression::Expression = #infix<terminal_expr> {
	#L x "+" y { expression::Expression::Binary("+".to_string(), Box::new(x), Box::new(y)) }
	   x "-" y { expression::Expression::Binary("-".to_string(), Box::new(x), Box::new(y)) }
	#L x "*" y { expression::Expression::Binary("*".to_string(), Box::new(x), Box::new(y)) }
	   x "/" y { expression::Expression::Binary("/".to_string(), Box::new(x), Box::new(y)) }
}

pub enclosed_expr -> expression::Expression
    = wh<"("> x:expression wh<")"> { x }

pub terminal_expr -> expression::Expression
    = enclosed_expr /
      _ x:int_value _ { expression::Expression::IntValue(x) } /
      _ x:identifier _ { expression::Expression::Variable(x) }

pub int_value -> i32
    = n:$("-"? [0-9]+) { n.parse().unwrap() }

pub identifier -> String
    = s:$([a-zA-Z][_a-zA-Z0-9]*) { s.to_string() }

pub data_type -> data_type::DataType
    = "Integer" { data_type::DataType::Integer }

wh<X> = _ X _

_ = ignored*
ignored = " " / "\n" 

